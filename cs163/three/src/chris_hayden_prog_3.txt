chris hayden program 3 163

I would defiantly do a few things different for my abstract data typo that I made for this program. Staring with adding 'this.' to all class members in there respective functions of the abstract data type that we are making for this program. This would make it far more readable and clear where the data is coming form and who owns it the data making it easy to read each function for that abstract data type. I some how didn't know this was possible. But more so if we wanted this to be used in production that there is plenty of placed that efficiency was sacrificed for simpler and cleaner code. Like where I copy the given data when adding to the abstract data type that I made instead of taking in the  data to be owned by the abstract data type that was made. There is also the fact that I get a better er understating of what works well in c++ (purely imperative style) and what dose not (everything else) so if I were simply to try again I would start from a different place. For instance I would start by writing the code to return the data as that appears to be the most useful part of the abstract data type and worst part of the whole program that I just wrote. Its bad for several reasons but a big one is how it always instantiates memory even of the node might be empty when iterating overt the abstract data type. This was mostly done to make the code easy to write, I could also talk about extra variables I made but this would be a silly improvement before other bigger issues.

As far how efficient the whole abstract data type that I just made Its still hard for me to give a straightforward answer. While I can say that there are plenty of places for easy speed or efficiency gains like when I instantiate node just to copy in to a new one. However Im still unsure about a base line speed or rather im not sure what would make things slow or less efficient. We have to loop to get data from the table abstract data type and we have to traverse liner liked lists to see if we have collisions so I cant just say not to do those things for speed so im in a place where I can see that I use memory or am calling allot of lower operations but I cant say this is too may calls or too much memory as that feels like something I need a bit more intuition around.

The first hash function I implemented is very simple. Add all ascii values together and multiply by table size. This is very strait forward way to accomplish the hash function but this wont allow the data to be dispersed thought the table as a lot of keys will be equal. The second is a little better as we simple average the data, this helps get a larger spread and lets the table fill more evenly.

The chaining or liner linked list used to handle collisions is probably the worst part from a conception stand point. Since we will need to traverse basically every time we want data from the list as we have to do a string compare.

For the use case of getting specific data for a data key like a string the abstract data type know as a table is perfect. Since the point of the abstract data type is not to organize or otherwise sort the data, storing can be as simple as entering the data in to an array. As the data wont change shape or grow in size the fixed length of an array is not an issue for the data. Though it will take more cpu time to allocate more memory if we have too many or wan to resize the table for some reason.
